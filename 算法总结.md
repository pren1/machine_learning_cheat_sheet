# 数组

二分查找：记得是left<=right, 然后要获得结果，去实际写一个例子出来看看到底是left还是right就好

双指针法：要么就是左右指针，要么就是快慢指针

最长回文子串：关于回文，可以从一个字符向两边扩，也可以从两个相等的字符向两边扩(做了～)

滑动窗口：也称双指针法。下面根据不同题目来分析：

1. 长度最小的总和小于k的连续数组

   start_index在外，while loop的index即为end_index。

   无论如何，一直往总和里添加。

   当当前总和大于k时（这是一个while loop），从start_index处减去nums[start_index]，直到当前总和再度小于k。

2. 水果成篮

   记住应用Counter(). 添加用append，取出用pop(element)。注意取出时先验证要取出的元素包不包含在Counter()中。

   不管什么条件，一直往Counter中添加新元素。然后有一个while loop，条件是预设条件不再被满足。换句话说，在while loop执行之后，预设条件一定是被满足的。找合适的地方更新最大值/最小值。

3. 最小覆盖子串：返回A字符串中覆盖B内所有字符的子串

   用Counter(B)构造一个need。每当你自己的Counter[char]等于need[char]时，value加一。当value等于need中字母种类时，不断增加start_index。**注意这是因为这里是子序列。**每次都从开头去除一个字母C = s[start]。在去除之前比较Counter[C]和need[C]。若二者相等，value减一。

4. 最长的无重复连续子串。如，从“abcabcbb”中可以找出“abc”

   和上面一样。在while loop内删除nums[start_index]时，记得验证它到底在不在Counter里。

5. 找到字符串中所有字母异位词：因为是连续的，所以当char不在p中时，要重置Counter，value以及start_index。这里while loop的条件是my_counter[char] > need[char]。**注意这里是必须连续的，**所以要用my_counter[char] > need[char]。在while loop之后，我们检查value和len(need)。

6. 注意3，4，5问题的核心区别其实是每一个字符包不包含在p中。对于3，不那么重要，因为是子序列。对于4，无所谓，因为它的p其实是所有字母的集合。对于5，要看看是不是在p中，不是则重置。

7. 另外，要注意题目要求p是否要在t中连续。如果需要连续，那么就不能用value==len(need)，因为value只有在my_dict[char]==need[char]时才会增加。比如babac和abc匹配。ba之后的ba不会增加value，但是bab已经不能连续匹配abc了。如果不要求连续，那么可以用value==len(need)

# 链表

1. 翻转链表：维护pre和cur。pre初始化为None。直接让cur指向pre，再把cur往后移，同时更新pre就行

2. 删除倒N个节点：如果fast指针为空，记得返回head.next。work version：fast从开头开始，slow从空头开始即可。。

3. 把一个链表分成两个时记得断掉节点的联系，把节点.next设置为None

4. 两两交换链表节点：不需要什么counter。注意总要确保计算node.next之前node不为None。这里一共要三个节点：pre，head，next_node。在交换完成后，pre的值为head，head的值为next_node。如此，直到head或head.next为空。

5. 环形链表2:当slow与fast相遇时，slow走了k步，则fast走了2k步。slow走了x+y步，fast走了x+y+n(y+z)步。有：

   x = (n-1)(y+z) + z

   从头节点出发一个指针，从相遇节点出发一个指针。当两者再度相遇，获得入口

# 哈希表

1. 350两个数组的交集2。如果两列表已排序，求它们的交集。这里可以用双指针法，每次移动较小的那个。
1. 四数之和2: 用前两个数组建立一个哈希表，然后对后两个数组，如果元素之和的负数存在于之前的哈希表，则把哈希表的值加入最后的结果。
1. 三数之和：用双指针法，并且特别需要注意三个数字的去重。

# 二叉树

1. 经典层序遍历：注意内外两个while main_queue，第一个while loop内建立新的sub_queue，第二个while loop内main_queue pop left. 第二个while loop结束之后把sub_queue配给main_queue。

2. 连接完美二叉树的每个节点：因为每个节点都有next，这里我们每层都从最左边的节点开始，连接好下一层。然后再去往下一层。

3. 对称二叉树：需要一个compare函数来比较两个node。注意考虑两个node分别为空的情况。然后比较node1的左和node2的右，以及node2的左以及node1的右。这样才叫对称。（做了～）

4. 二叉树最小深度：注意，如果一个node只有右子树，那应该返回右子树的最小深度+1，而非0。左子树同理。**树类题目有时需要考虑左右子树是否为空的情况。**（做了～）

5. 完全二叉树的节点数：先判断当前树是否为满二叉树，如果是，则根据公式返回二叉树节点数。如果不是，则继续遍历左右子树，并在结果上+1。（做了～）

6. 左子叶之和：关键在于怎样判断当前节点是左子树。我们可以在helper函数的参数中使用一个布尔变量。当前往左节点时，此变量为真。

7. 找树左下角的值：这里还是在helper函数中加入额外参数。比如这里加入了深度作为额外参数，然后对二叉树进行中序遍历。每当新的深度产生时，记录该节点即可。到最后，深度最高的那个节点即为最下角的点。注意最后一层的其他节点并没有被算在内，因为它们并没有更高的深度。

8. 从中序后序遍历构造二叉树：关键是找到根节点的位置，并根据根节点分割下一步要用到的中序/后序构造数组。注意这里很有用的一个函数是list.index(target_val), 用于找到target_val在list中的index。

9. 验证二叉搜索树：记得用中序遍历，并且维持一个pre变量来储存上一个节点的值。确认当前节点大于pre节点就好。**套路：在recursion树时引入外部变量进行操作。**

10. 二叉树的最近公共祖先：用helper函数返回：以输入的root节点为根节点的树里是否含有左或右目标。这里考虑两种情况，第一种是当前节点为左或右。此时返回True。如果发现当前节点的左右已经有一个为True，则找到了节点。第二种情况是当前节点的左右都返回True，此时当前节点即为公共祖先。

11. 二叉搜索树的最近公共祖先：利用递归，当左右目标都大于当前值，往右走。反之往左走。当左右各有一个目标，我们已经找到。

12. 二叉搜索树的插入操作：比较当前节点与目标值的大小。如果往左，但是左边没有节点，直接插入即可。右侧同理。

13. 删除二叉搜索树中的节点：需要分情况讨论。但是核心在于要用函数返回一个节点，并且设置成当前节点的左右子树：

    root.left = helper(root.left, key)

    root.right = helper(root.right, key)

14. 修建二叉搜索树：确保二叉树的值在一个区间内。当当前节点的值在区间之外，返回对左或右子树修剪的结果。否则，分别将左右子树的值设置为修剪后的结果。

# **动态规划**

**0-1背包问题**

**一维：先coins数组，再reverse第二层数组以防止重复计算（看动归公式就能看出来）**

**可解问题：一堆数，给定一个上限，求能获得的最大和**

**可解问题2: 一堆数，给定一个目标值，求有多少种方法达到此目标值：此时注意初始化，dp[0]为1，因为什么都不做算是一种方法**

也注意j循环是从0开始，不是从1开始...



**完全背包问题**

**每种物品有无限件**

也就是说，在当前总容量为j的情况下，我们可以试着从i-1层拿取以下物品：不用coin，用一个coin，用两个coin......

**和0-1的区别是第二层不用reverse**

**物品在外，coins数组在内是set不重复的情形**

**coins数组在外，物品在内是顺序不同算不同的情形**



**硬币数问题：最少需要多少硬币组成目标金额？dp[j] = min(dp[j], dp[j-current_val]+1). +1 是因为选了一个，所以硬币数加一。注意这里coins数组在外层，因为硬币顺序先后并不重要。**



**最长上升子序列：在过去的序列中寻找比当前小的dp，然后选中（+1）**

**最长重复子数组：当i和j相等时，dp为[i-1][j-1] + 1**



**问题如果是两个字符串，判断子序列之类的，需要用到dp**



**有序列A和B。**

**如果是相互的，那么子串分为：**

1. **连续子串：dp[i][j] = dp[i-1][j-1]+1**
2. **不连续子串: dp[i][j] = max(dp[i-1][j], dp[i][j-1])**



如果是单向的，有两种问题：

1. 判断B是不是A的不连续子串。因为是单向的，所以是dp[i][j-1]
2. 判断B含有的A子串的数目。注意当两个字符相等时，可以选该字符，也可以不选并从B中删除一个字符。即：dp[i][j] = dp[i-1][j-1] + dp[i][j-1]



回文子串

连续与不连续的区别在于，连续的情况下，必须是dp[i+1][j-1]为回文才可以推广到dp[i][j].



# 堆/优先队列

1. 滑动窗口最大值

   一直向一个大顶堆里加数据，key是数据本身，value是数据的index。如果当前最大值在窗口之外，将其从大顶堆中排除。

2. 前k个高频元素

   一直向一个小顶堆里加数据（heapq.heappush(your_list, (key, value))），key是该数据的频率，value是数据本身。如果小顶堆的大小大于k，那么用heapq.heappop()弹出最小的那个（注意大顶堆的话，每次都弹出最大的）。这样的话，我们就能一直维持一个大小为k的小顶堆

3. 每日温度/下一个更大元素

   求数组中下一个最大元素要用单调栈。此栈顶永远是下一个最大元素。如果此栈为空，那下一个最大元素不存在。具体实现是先逆向遍历数组，在循环内首先用一个while循环，不断判断当前数组元素是否大于等于栈顶元素。如果大于等于，那么从栈顶pop，直到条件不符合。在每个循环的最后把当前元素入栈。



# labuladong

1. 岛屿问题

   https://leetcode.cn/problems/number-of-distinct-islands/

   注意这里，我用path作为函数的输入，path在函数中被修改，然后结果反应到函数之外。这里将遍历岛屿土地的顺序序列化，从而得到了独立的岛屿数目。

2. 

# 亚马逊欧诶50题

1. GetkConsistency Score

   难点在于要认识到这里可以对数组的差用滑动窗口法。即：先计算数组各元素的差，然后用滑动窗口法计算和为k的最长连续序列...

2. 找最近的餐馆

   直接用sort函数，按朝餐馆的距离排序。或者用大根堆，求前k个最小元素...

3. combo 问题

   优先级队列。先计算所有正数的和，然后把所有负数转化为正数。这样问题就变成了，给定数组，求前k个最小子数组分别的和。

   对数组排序

   小根堆中第一个元素为当前的最小和，第二个元素为最小子数组最后一个元素的index。

   循环k-1次，每次从小根堆里取一个最小的组，把其中第一个元素放入列表sub_array_sum。如果第二个元素为pre_index，那么有两种情况：

   要么用pre_index的元素，并且加上pre_index+1的元素。要么从和里减去该元素。把结果和新的pre_index+1压入小根堆即可。

   最后的结果为：所有正数的和，所有正数的和分别减去每一个sub_array_sum里的元素即可。

4. ceil problem

   哈希表的应用

5. minimum total lag

   把两个数组排个序，再计算各元素绝对差值就好

6. 后一个数是前一个数的平方数序列

   在[2,8,9,16,4,3]中，比如[2,4,16],2的平方是4，4的平方是16。就是一道最大递增子序列的变种题目...

7. findlongestlist: 略

8. Common prefix

9. 学生排队：单调栈，但是太难啦

10. 分割子串共同数目大于k

    解法比较像是dynamic programming。我们用左右两个哈希表来计算左右子串的数目，每次只关注更改的那个character。

11. number of unique average values

    优先级队列即可。来一个大根堆和小根堆，循环n//2次，每次分别从两个堆中获取当前最大/最小的值，然后取和放到一个hashset即可。

12. 更换password

    用双指针法判断一个字符串是否为另一个字符串的子串即可。这里我不知道怎么用动态规划做

13. lex smallest palindrome

    这里解答把字符串长度分为奇偶两种情况讨论。如果是奇数长度，那么在前一半sort的字符串后加入中间的那个字符，然后加入反转后的前一半sort后的字符串。

14. maximize the number of AZ

    A肯定要加在开头才能尽可能多的和后面的Z组成AZ，Z肯定要加在最后才能尽可能多的和前面的A组成AZ。

15. 九宫格点击数

    用hashmap（counter）记录每个字符的出现频率，并且排序。前九个高频的让它们点击数为1，九到十八个高频的让它们点击数为2，剩下的点击数为3即可。

16. book retail

    用优先级队列（小根堆）即可。用一个变量跟踪下一本要买的书，当小根堆的顶部等于这本书时，heappop，并查看下一本书在不在小根堆的堆顶，如果在，继续pop（购买）

17. linkedlist shopping cart

    只是简单的链表操作。其中需要往链表尾部添加node节点。注意维护一个尾部节点，并且，当头节点为空时，记得重置尾部节点到dummy节点。再就是求next之前永远注意链表本身不为None。

18. 服务器移动

    没有再看一遍的意义，过于简单

19. s里拼t

    简单题，之后重新做吧

20. 密码原音辅音

    简单题，之后重新做吧

21. 最大的processor cluster

    连续cluster问题，可以用滑动窗口法做。这里额外有求窗口中最大值的部分，我们用大根堆来随时返回最大值即可。注意在while loop中，start_index增加时大根堆也要同时弹出：

    ```python
    maxHeap.remove(target_element)
    heapq.heapify(max_heap)
    ```

22. 连续递增子序列个数

    迷一般的dp，dp[i] = dp[i-1] + 1，就是把新的一个字符加到所有i-1能形成的子序列里。再加上本身是1，就这样...

23. FindminHealth

    贪心算法即可，简单题

24. 一看困难，润了

25. pascal triangle

    



# Blind 75

1. 最大子数组乘积

   维持一个最大乘积，最小乘积。然后在每次更新时，考虑num[i], min_val * num[i]. max_val * num[i]。然后分别更新它们 (有时间再做一遍)

2. 旋转数组中找最小值

   用中值和最右边的值比，如果小于，中值右侧的数据可以丢弃（中值不能丢，所以right=mid)。如果大于右侧，那么左侧数据可以丢弃，包括中值也可以丢，因为它大于一个数，自身不可能是最小（所以left=mid+1）

3. 在旋转数组中寻找目标值

   关键在于，找到有顺序的那段数组。这段数组可以在左，也可以在右边。我们通过比较中间值和右侧的值来判断。如果中间值小于右侧值，说明从中间到右侧这段数组有序。反之，从左边到中间这段数组有序。一旦找到有序数组，我们看看目标值在不在其中（比较有序数组的两端值和目标值）如果不在其中，那么接下来的循环将在另一侧进行。

4. 三数之和

   关键在于去重，改天再做 (做了～)

5. 太平洋大西洋水流

   用dfs，不要用什么动态规划...

6. 最长连续序列

   实际上是dfs岛屿问题，用visit数组记录曾经访问过的数据即可。另外，dfs(num-1) + dfs(num+1) + 1即为本“岛屿”的面积...

7. 会议室2

   区间问题一般都是先把区间按开始值排序：key=lambda x:x[0]. 这里我们每次试着把新区间加入已有的会议室。如果加不了，那么新开一个。如果能加，直接加就好，**因为每个区间的开始值都是固定的，计算当前开始值和之前结束值之间的差没什么意义**。以上看法值得商榷。每次查看最早结束的会议室还是有意义的。

8. 合并k个升序链表

   **之后再做一遍** (做了～)

# 勤加练习

1. 字典树，呃...(做了～)

# 花花列表

1. 在动态规划二维转一维时，j循环是否用reverse，要看你要用的是不是已经update的$dp[j]$

2. 删除并获得点数：和rob问题一样，关键在于转化出rob_list。

   为什么我的办法不好使：比如现在是4，3如果不存在于dict中，它还是可以有值的，不是0。这也是要先转化出rob_list的原因...

3. 508: 出现次数最多的子树元素和。对于不知道怎么处理的叶子节点问题，可以找个很简单的树模拟一下

4. 437: 路径总和3。模版：dfs输入有当前node，以及target。每次进入下一层时，都将target减去当前值。因此，

   if node.left:

   ​	target - node.left.val。然后当target值为0时，counter加一。

5. BFS: 如果是neighbors，之前也没访问过，就加入队列呗

   有向图：bfs遍历要用到入度出度法，即，当入度为0时加入队列

   无向图：bfs遍历不用入度出度，因为根本没有入度出度......

6. 1162: 试用动态规划方法解题

7. 802: 记录所有不在图内的节点

8. 判断二分图：可以在前往neighbor循环中判断颜色是否正确。即，获取目前颜色，把相反颜色分配给子节点。如果子节点已有颜色，那么查看其颜色是否和当前颜色相反。若否，则二分失败～

9. 863:bfs的层数敏感与层数不敏感。如果是层数敏感情况，你要加两层while loop

10. 1129:tricky. 看起来简单，但是实际上有陷阱。即：有环路的存在。在这种情况下，visited不仅要加节点，还要加入当前是否为红。在判断时，用neighbor_{not red}。注意这里用not red，因为neighbor已经是下一层，red值和当前层相反......

11. 986: 区间列表交集，通过观察，比较每个区间的末尾。每次往后移动较小的那个区间列表。注意一种情况是，交集区间的开头不能大于结尾

12. 752: 当向sub_queue添加元素时，要注意同时标记其为visited。否则每次循环结束，sub_queue都含有大量重复元素，会导致超时

13. 542: 0-1矩阵问题，可以把0看成一整块“超级0”，这样再求其他1到0的距离即可。

14. 698: 回溯分割问题，**值得一做**

15. 241: An elegant solution...分治法

    ```python
      class Solution:
        def diffWaysToCompute(self, input: str) -> List[int]:
            # 如果只有数字，直接返回
            if input.isdigit():
                return [int(input)]  
            res = []
            for i, char in enumerate(input):
                if char in ['+', '-', '*']:
                    # 1.分解：遇到运算符，计算左右两侧的结果集
                    # 2.解决：diffWaysToCompute 递归函数求出子问题的解
                    left = self.diffWaysToCompute(input[:i])
                    right = self.diffWaysToCompute(input[i+1:])
                    # 3.合并：根据运算符合并子问题的解
                    for l in left:
                        for r in right:
                            if char == '+':
                                res.append(l + r)
                            elif char == '-':
                                res.append(l - r)
                            else:
                                res.append(l * r)
    
            return res
    ```

16. 162:从爬坡到二分

# 九章算法

1. 406:和大于S的最小子数组：使用二分法+前缀和来实现nlogn的搜索。注意二分搜索之后还是要确认是否满足条件，因为left可能一直往右走直到越界。

2. 1565：

   1. BFS法：重点在于需要在前往下一个level之前把所有的直达节点都访问到。不然就会出现本来能直达的节点被下一步预先访问的状况
   2. SFPA法：比较visited_map的值，如果要更新的值比当前值还小，那么加入队列。SFPA：shortest path fast algorithm. **SFPA 好一些，容易想一些...**

3. 573: 邮局问题，再做一遍，注意再做时要从房子出发...需要记录每个空地能到达的房子总数，确保目标空地能到达所有房子 (**做了～**)

   1. 如果没有思路就先写一点框架类的东西，慢慢的就有思路了。你不可能把所有东西都在脑子里过一遍再写......

4. 789: 迷宫三：当距离小的时候，path直接被更小的path更新了。有时间再做（**做了～**）

5. 794: 滑动拼图二，需要熟悉二维到一维的转换，这里是主要难点。。。

   x = zero_index//3

   y = zero_index%3

   

   new_x*3 + new_y

6. 二叉树对称：可以用层序遍历，但是需要把空节点设置为‘#’。

7. 前序遍历非递归版本/中序遍历非递归版本

8. 864:如果是求和相等的两部分，可以试着求总和然后除以二。当然也要注意特殊情况，比如：

   ![Screen Shot 2022-12-19 at 9.20.57 PM](/Users/renpeng/Desktop/Screen Shot 2022-12-19 at 9.20.57 PM.png)

9. 634: 可行性剪枝: 即，看看当前之后的前缀还存不存在。如果不存在则可以直接剪枝（即跳过之后的搜索～）

10. 815:课程表IV, 结合dfs与combination，运用indegree数组和visited来决定节点遍历顺序

11. 单词拆分2:记忆化搜索到底能不能学会啊......（找时间重新做吧）

# 九章算法+

1. 60 search insert position. 经典二分法，很有用
2. 273: 考试策略，经典背包算法
3. 75：寻找峰值，二分法
4. 20: 骰子求和，模拟型动态规划
5. 33: N皇后，记忆化搜索的关键是dfs要返回值，以及要有一个便利的当前状态
6. 77:最长公共子序列，区间型动态规划经典题目
7. 120: 单词接龙：经典bfs
8. 122: 直方图最大矩形覆盖，要从每一根直方图开始，找到左右第一个小于的位置以构造最大矩形
9. 123:单词搜索，经典二维dfs
10. 127: 拓扑排序练习
11. 136: 分割回文：经典dfs
12. 191:乘积最大子数组，回溯型动态规划
13. 194: dfs+字典树，这里的操作是把字典树的node作为dfs的参数输入，然后直接查询node.children
14. 333: 识别字符串，前缀树经典应用
15. 406: 和大于S的最小子数组：**前缀和数组 + 二分法**
16. 436: 最大矩形，二维矩阵型动态规划
17. 444: 图是否是树2，茶饼机
18. 573: 建立邮局，经典二维bfs
19. 582: 单词拆分2，dfs+记忆化搜索
20. 588: 划分和相等的子集，背包问题之目标和存不存在
21. 630 · 骑士的最短路径II，bfs
22. 789 · 迷宫III，SFPA
23. 805 · 最大关联集合，茶饼机，给定一个元素，如何找到所有和它相连的元素～
24. 1375 · 至少K个不同字符的子串，滑动窗口
25. 1422 · 访问所有节点的最短路径，dfs+visited哈希表，有点sfpa的感觉
26. 1448 · 卡牌游戏，多维背包问题







